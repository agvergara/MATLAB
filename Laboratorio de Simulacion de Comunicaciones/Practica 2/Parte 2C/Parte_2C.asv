% **********************************************
% Practia 2, parte C: Efectos del canal
% Antonio Gomez Vergara - GIST
% **********************************************
clear all
close all
clc
simb = 1000;
vector_SNR = (0:1:20);
%% Parte2C.1 Modulacion QPSK para atravesar distintos canales
Mmod = 4; %Orden de modulacion: QPSK
Nb = simb*log2(Mmod); %Numero de bits totales
data= randi([0 1], Nb, 1); %Generacion de bits
%Modulamos
mod = modem.pskmod('M', Mmod, 'SymbolOrder','gray', 'InputType', 'bit');
modData = modulate(mod, data);
% Ahora simulamos los canales
%% AWGN
[BERawgn, ~, ~, ~, ~, ~] = efectocanal (
contador = 1;
for SNR = vector_SNR,
   snr = 10^(SNR/10);
   w = (randn(length(modData),1) + 1i.*randn(length(modData),1)) * (1/sqrt(2)) * sqrt(1/snr);
   y = modData + w;
   demoData = demodulate(modem.pskdemod(mod),y);
   BERawgn(contador) = sum((data~=demoData))./Nb;
   contador = contador + 1;  
end
%% Multitrayecto
    taps = [1 -0.3 0.1];
    % y = h*x+n? h = taps, multiqpsk = h*x, n???
    multiqpsk = filter(taps, 1, modData); %Hallamos la señal con multitrayecto
    demomultiData = demodulate(modem.pskdemod(mod),multiqpsk);
    %Hallamos la BER comparando con los datos originales
    for i = vector_SNR
        BERmultisinec(i+1) = sum((data~=demomultiData))./Nb;
    end
 %% Doppler con desvanecimiento Rayleigh
 %El canal Rayleigh sigue una distribución Gaussiana tanto en su parte real
 %como en su parte imaginaria.
  for i = vector_SNR
    h = ((randn(1,simb) + 1i.*randn(1,simb)) * sqrt(1/2))'; %Generacion del canal Rayleigh  
    %Canal plano.
    doppler = h.*modData;
    demodoppData = demodulate(modem.pskdemod(mod),doppler);
    BERdoppsinec(i+1) = sum((data~=demodoppData))./Nb;
  end
%% Representaciones
semilogy(vector_SNR, BERawgn, '-r')
hold on
semilogy(vector_SNR, BERmultisinec, '-b')
hold on
semilogy(vector_SNR, BERdoppsinec, '-g')
legend ('AWGN', 'Multipath no ecualiz', 'Doppler no ecualiz');
title('Efectos del canal')
xlabel('SNR(dB)');
ylabel('BER');
hold off
%% Parte 2C.2: SNR de 0 a 20dB usando modulaciones BPSK y DBPSK
modbpsk = modem.pskmod('M', 2, 'SymbolOrder','gray', 'InputType', 'bit');
moddbpsk = modem.dpskmod('M', 2, 'SymbolOrder','gray', 'InputType', 'bit');

%Ecualizador ZF https://es.mathworks.com/matlabcentral/fileexchange/39470-zero-forsing-equalizer/content/ZF.m
